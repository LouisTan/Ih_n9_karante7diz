% conv_rgb2ycbcr: converts an 8-bit-depth RGB image to Y'CbCr format using optional 4:2:0 subsampling
function [Y, Cb, Cr] = conv_rgb2ycbcr(RGB, subsample)
    assert(numel(RGB)>0 && size(RGB,3)==3);
    %Y = zeros(size(RGB,1),size(RGB,2),'uint8');
   
    img_s = size(RGB);
    
    RGB_420 = [];
    RGB_444 = [];
    YCbCr = [];
    
    R = [];
    G = [];
    B = [];
    
    %4:4:2
    if subsample == false
        p = 1:img_s(3);
        n = 1:2:img_s(1);
        m = 1:2:img_s(2);

        z = 1;
        for k = p
            y = 1;
            for j = m
                x = 1;
                for i = n
                    YCbCr(x,y,z) = RGB(i,j,k);
                    x = x + 1;
                end
            y = y + 1;    
            end
        z = z + 1;
        end
    end
    Y = 0.299*R + 0.587*G + 0.114*B;
    Cb = 128 + 0.564*(B - Y);
    Cr = 128 + 0.713*(R - Y);
    
    %4:4:4
    if subsample
        YCbCr = [Y Cb Cr];
    end
    
    %disp(YCbCr);
    
    compr_rate = 1.0 - (numel(YCbCr)./(numel(YCbCr)));
    fprintf('\t... compression rate = %f\n',compr_rate);
    
end